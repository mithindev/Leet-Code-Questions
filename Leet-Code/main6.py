# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # from typing import List


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def helper(self, coins, amount):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         # BASE CASE
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if amount == 0:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if amount < 0:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return 10000000
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         minimum = 10000000

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for i in coins:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             ans = self.helper(coins, amount - i)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if ans != 10000000:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 minimum = min(minimum, ans + 1)
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return minimum  

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def coinChange(self, coins: List[int], amount: int) -> int:
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return self.helper(coins, amount)


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.coinChange([1, 2, 5], 11))


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def helper(self, n, row):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = row

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         # BASE CASE
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if n == 0:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return ans

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for i in row:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if i == '0':
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans += '1'
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans += '0'
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return self.helper(n - 1, ans)
    
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def kthGrammar(self, n: int, k: int) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = self.helper(n, '0')

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return int(ans[k])

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.kthGrammar(1, '0'))


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def helper(self, n, row):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = row

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         # BASE CASE
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if n == 0:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return ans

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for i in row:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if i == '0':
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans += '1'
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans += '0'
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return self.helper(n - 1, ans)
    
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def kthGrammar(self, n: int, k: int) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         #BASE CASE
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if n == 0 or k == 1:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         mid = pow(2, n - 1) // 2

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if k <= mid:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             ans = self.kthGrammar(n - 1, k)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             ans = 1 ^ self.kthGrammar(n - 1, k - mid)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans 



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # n = 2
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # k = 2
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # result = solution.kthGrammar(n, k)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(result)


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # for i in range (5, 1 - 1, -1):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #   print(i, ',') 


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def isPalindrome(self, word, i, j, dp):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         # BASE CASE
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if j <= i:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return True

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if dp[i][j] != -1:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return dp[i][j]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if word[i] == word[j]:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             dp[i][j] = self.isPalindrome(word, i + 1, j - 1, dp)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return dp[i][j]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             dp[i][j] = False
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return False

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def longestPalindrome(self, word: str) -> str:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         dp = [[-1 for _ in range(len(word))] for _ in range(len(word))]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = ""

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for i in range(len(word)):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             for j in range(len(word) - 1, i - 1, -1):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 if self.isPalindrome(word, i, j, dp) and (j - i + 1) > len(ans):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     ans = word[i:j+1]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.longestPalindrome("babad"))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # Definition for a binary tree node.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class TreeNode:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def __init__(self, val=0, left=None, right=None):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         self.val = val
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         self.left = left
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         self.right = right

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def helper(self, parent, node, target):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         # BASE CASE
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if not node:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return None

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         node.left = self.helper(node, node.left, target)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         node.right = self.helper(node, node.right, target)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if not node.left and not node.right and node.val == target:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return None

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return node

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if not root:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return None

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         root = self.helper(None, root, target)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return root


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # from typing import List


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def helper(self, num):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 2
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         _sum = 1 + num

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for i in range(2, int(num ** 0.5) + 1):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if num % i == 0:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans += 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 _sum += i
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if ans > 4:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 return 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if ans == 4:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return _sum
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def sumFourDivisors(self, arr: List[int]) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for i in arr:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             ans += self.helper(i)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans
    

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.sumFourDivisors([21]))


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(type(bin(4)))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # from typing import List

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def sortByBits(self, arr: List[int]) -> List[int]:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = sorted(arr, key=lambda x: (bin(x)[2:].count('1'), x))
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.sortByBits([0, 1, 2, 3, 4, 5, 6, 7]))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def minSteps(self, s: str, t: str) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         count_s = {}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         count_t = {}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for char in s:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             count_s[char] = count_s.get(char, 0) + 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for char in t:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             count_t[char] = count_t.get(char, 0) + 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for char, freq_s in count_s.items():
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             freq_t = count_t.get(char, 0)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if freq_s > freq_t:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans += freq_s - freq_t

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def minSteps(self, s: str, t: str) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         countS = {}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         countT = {}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for ch in s:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if ch not in countS:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 countS[ch] = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 countS[ch] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for ch in t:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if ch not in countT:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 countT[ch] = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 countT[ch] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for ch, count in countS.items():
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             freq = countT.get(ch, 0)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if count > freq:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans += count - freq

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.minSteps("leetcode", "practice"))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # from typing import List


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def getWinner(self, arr: List[int], k: int) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         n = len(arr)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if k >= n:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return max(arr)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         i = 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         streak = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         while True:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             winner = arr[i]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if arr[(i + 1) % n] < winner:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 streak += 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 i = (i + 1) % n
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 if streak >= k:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     return winner
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 winner = arr[(i + 1) % n]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 streak = 1
            

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.getWinner([2,1,3,5,4,6,7], 2))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def helper (self, s):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for i in s:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             ans += int(i)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return str(ans)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def digitSum(self, s: str, k: int) -> str:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         temp = ""

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         while(len(s) != k):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             temp = self.helper(s)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             s = temp
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return s

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.digitSum("11111222223", 3))


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def helper (self, s):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         n = len(s)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return (0.5 * n * (n + 1)) % (pow(10, 9) + 7)
    
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def countHomogenous(self, word: str) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         lst = {}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         s = 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         e = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         n = len(word)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         while (e < n and s < n):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if word[e] == word[s]:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 e += 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 temp = word[s: e]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 if temp not in lst:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     lst[temp] = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     lst[temp] += 1
                
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 s = e
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 e = s + 1
            
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         temp = word[s: e]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if temp not in lst:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             lst[temp] = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             lst[temp] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         # print(lst)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for key, val in lst.items():
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             ans += self.helper(key) * val
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans % (pow(10, 9) + 7)


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.countHomogenous("zzzzz"))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def repeatedStringMatch(self, a: str, b: str) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         word = a
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         count = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         while True:

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if len(a) < len(b):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 a += word
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 count += 1
            
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 if b in a:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     return count
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 elif len(a) < 2*len(b):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     a += word
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     count += 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     break
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return -1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.repeatedStringMatch("aaaaaaaaaaaaaaaaaaaaaab", "ba"))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def helper (self, s):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         n = len(s)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return (0.5 * n * (n + 1)) % (pow(10, 9) + 7)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def arrub(self, word: str) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         lst = {}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         s = 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         e = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         n = len(word)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         while (e < n and s < n):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if word[e] == '1':
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 e += 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 temp = word[s: e]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 if temp not in lst:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     lst[temp] = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     lst[temp] += 1
                
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 s = e
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 e = s + 1
            
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         temp = word[s: e]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if '0' not in temp and temp not in lst:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             lst[temp] = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         elif temp in lst:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             lst[temp] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         print(lst)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         # for key, val in lst.items():
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         #     ans += self.helper(key) * val
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         # return int(ans)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution.arrub("0110111")


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def findSubSeq(self, word, p, ans, dp):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if not word:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             ans.add(p)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return ans

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if (word, p) in dp:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             return dp[(word, p)]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ch = word[0]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans.add(p + ch)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         inc = self.findSubSeq(word[1:], p + ch, ans, dp)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         exc = self.findSubSeq(word[1:], p, ans, dp)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         dp[(word, p)] = ans.copy()

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def distinctSubseqII(self, s: str) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         dp = {}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         subSeq = self.findSubSeq(s, "", set(), dp)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return len(subSeq) % (pow(10, 9) + 7) - 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.distinctSubseqII("aaa"))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def distinctSubseqII(self, s: str) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         visited = [-1] * 27
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         visited[0] = 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for ch in s:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             index = ord(ch) - ord('a') + 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if visited[index] != -1:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans = (2 * ans - visited[index - 1]) % (10**9 + 7)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans = (2 * ans) % (10**9 + 7)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             visited[index] = ans

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return (ans - 1) % (10**9 + 7)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # Example usage
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # result = solution.distinctSubseqII("aaa")
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(result)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution: 
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def helper(self, ch, s):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         i1 = s.index(ch)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         i2 = s.rfind(ch)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return [i1, i2]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def countPalindromicSubsequence(self, s: str) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         chars = set(s)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for ch in chars:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             index = self.helper(ch, s)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if index[0] != index[1]:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans += len(set(s[index[0] + 1: index[1]]))
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.countPalindromicSubsequence("aabca"))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # from typing import List

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def isPossible(self, weights, mid, days):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         sum = 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         day = 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for weight in weights:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if sum + weight <= mid:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 sum += weight
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 day += 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 if day > days or mid < weight:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                     return False
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 sum = weight
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return True

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def shipWithinDays(self, weights: List[int], days: int) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         s = 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         e = 0
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for weight in weights:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             e += weight
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         while (s <= e):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             mid = s + (e - s) // 2

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if self.isPossible(weights, mid, days):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 ans = mid
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 e = mid - 1
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 s = mid + 1
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.shipWithinDays([1,2,3,4,5,6,7,8,9,10], 5))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # from typing import List


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #     def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #         n = len(arr)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #         arr.sort()

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #         if arr[0] != 1 and 1 in arr:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #             i = arr.index(1)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #             arr[0], arr[i] = arr[i], arr[0]
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #         else:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #             arr[0] = 1
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #         for i in range(1, n):
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #             if abs(arr[i] - arr[i - 1]) > 1:
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #                 arr[i] = arr[i - 1] + 1
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #         return max(arr)


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.maximumElementAfterDecrementingAndRearranging([73,98,9]))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # # # #     def countPrimes(self, n: int) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # # # #         table = [True] * (n + 1)
# # # # # # # # # # # # # # # # # # # # # # # # # # # #         table[0] = table[1] = False
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # #         count = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # #         for i in range(2, n):
# # # # # # # # # # # # # # # # # # # # # # # # # # # #             if table[i]:
# # # # # # # # # # # # # # # # # # # # # # # # # # # #                 count += 1
                
# # # # # # # # # # # # # # # # # # # # # # # # # # # #                 j = 2 * i
# # # # # # # # # # # # # # # # # # # # # # # # # # # #                 while (j <= n):
# # # # # # # # # # # # # # # # # # # # # # # # # # # #                     table[j] = False
# # # # # # # # # # # # # # # # # # # # # # # # # # # #                     j += i
        
# # # # # # # # # # # # # # # # # # # # # # # # # # # #         return count
    
# # # # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.countPrimes(10))


# # # # # # # # # # # # # # # # # # # # # # # # # # # def gcd(a, b): 
# # # # # # # # # # # # # # # # # # # # # # # # # # #     if a == 0: 
# # # # # # # # # # # # # # # # # # # # # # # # # # #         return b 
  
# # # # # # # # # # # # # # # # # # # # # # # # # # #     return gcd(b % a, a)

# # # # # # # # # # # # # # # # # # # # # # # # # # # print(gcd(72, 24))

# # # # # # # # # # # # # # # # # # # # # # # # # # import math
# # # # # # # # # # # # # # # # # # # # # # # # # # from typing import List


# # # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # # #     def Pow(self, a, n, dp):
# # # # # # # # # # # # # # # # # # # # # # # # # #         # BASE CASE:-
# # # # # # # # # # # # # # # # # # # # # # # # # #         if n == 0:
# # # # # # # # # # # # # # # # # # # # # # # # # #             return 1
        
# # # # # # # # # # # # # # # # # # # # # # # # # #         if dp[n] != -1:
# # # # # # # # # # # # # # # # # # # # # # # # # #             return dp[n]

# # # # # # # # # # # # # # # # # # # # # # # # # #         if n % 2 == 1:
# # # # # # # # # # # # # # # # # # # # # # # # # #             res = self.Pow(a, n // 2, dp) * self.Pow(a, n // 2, dp)
# # # # # # # # # # # # # # # # # # # # # # # # # #             dp[n] = res * a
# # # # # # # # # # # # # # # # # # # # # # # # # #             return dp[n]
# # # # # # # # # # # # # # # # # # # # # # # # # #         else:
# # # # # # # # # # # # # # # # # # # # # # # # # #             dp[n] = self.Pow(a, n // 2, dp) * self.Pow(a, n // 2, dp)
# # # # # # # # # # # # # # # # # # # # # # # # # #             return dp[n]


# # # # # # # # # # # # # # # # # # # # # # # # # #     def superPow(self, a: int, b: List[int]) -> int:
# # # # # # # # # # # # # # # # # # # # # # # # # #         n = ""
# # # # # # # # # # # # # # # # # # # # # # # # # #         for i in b:
# # # # # # # # # # # # # # # # # # # # # # # # # #             n += str(i)
# # # # # # # # # # # # # # # # # # # # # # # # # #         n = int(n)

# # # # # # # # # # # # # # # # # # # # # # # # # #         dp = [-1] * (n + 1)

# # # # # # # # # # # # # # # # # # # # # # # # # #         return self.Pow(a, n, dp)

# # # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # # print(solution.superPow(10, [1, 0]))
# # # # # # # # # # # # # # # # # # # # # # # # # from typing import List

# # # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # # #     def toBinary(self, num, l):
# # # # # # # # # # # # # # # # # # # # # # # # #         ans = ""
# # # # # # # # # # # # # # # # # # # # # # # # #         if num == 0:
# # # # # # # # # # # # # # # # # # # # # # # # #             for i in range(l):
# # # # # # # # # # # # # # # # # # # # # # # # #                 ans += "0"            
        
# # # # # # # # # # # # # # # # # # # # # # # # #         while(num > 0):
# # # # # # # # # # # # # # # # # # # # # # # # #             d = num % 2
# # # # # # # # # # # # # # # # # # # # # # # # #             ans = str(d) + ans
# # # # # # # # # # # # # # # # # # # # # # # # #             num = num // 2
        
# # # # # # # # # # # # # # # # # # # # # # # # #         for i in range(l - len(ans)):
# # # # # # # # # # # # # # # # # # # # # # # # #             ans = "0" + ans

# # # # # # # # # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # # # # # # # #     def findDifferentBinaryString(self, arr: List[str]) -> str:
# # # # # # # # # # # # # # # # # # # # # # # # #         n = len(arr)
# # # # # # # # # # # # # # # # # # # # # # # # #         arr = set()

# # # # # # # # # # # # # # # # # # # # # # # # #         for binary in arr:
# # # # # # # # # # # # # # # # # # # # # # # # #             arr.add(int(binary, 2))
# # # # # # # # # # # # # # # # # # # # # # # # #         print(arr)
        
# # # # # # # # # # # # # # # # # # # # # # # # #         for i in range(0, len(arr) + 1):
# # # # # # # # # # # # # # # # # # # # # # # # #             if i not in arr:
# # # # # # # # # # # # # # # # # # # # # # # # #                 return self.toBinary(i, n)
        
# # # # # # # # # # # # # # # # # # # # # # # # #         return "0"

# # # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # # print(solution.toBinary(1, 2))
# # # # # # # # # # # # # # # # # # # # # # # # # print(solution.findDifferentBinaryString(["00","01"]))
# # # # # # # # # # # # # # # # # # # # # # # # from typing import List

# # # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # # #     def threeSum(self, arr: List[int]) -> List[List[int]]:
# # # # # # # # # # # # # # # # # # # # # # # #         n = len(arr)
# # # # # # # # # # # # # # # # # # # # # # # #         ans = set()
# # # # # # # # # # # # # # # # # # # # # # # #         count = {}

# # # # # # # # # # # # # # # # # # # # # # # #         for i in arr:
# # # # # # # # # # # # # # # # # # # # # # # #             if i not in count:
# # # # # # # # # # # # # # # # # # # # # # # #                 count[i] = 1
# # # # # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # # # # #                 count[i] += 1
        
# # # # # # # # # # # # # # # # # # # # # # # #         for i in range(n):
# # # # # # # # # # # # # # # # # # # # # # # #             n1 = arr[i]
# # # # # # # # # # # # # # # # # # # # # # # #             count[n1] -= 1
# # # # # # # # # # # # # # # # # # # # # # # #             for j in range(i + 1, n):
# # # # # # # # # # # # # # # # # # # # # # # #                 n2 = arr[j]
# # # # # # # # # # # # # # # # # # # # # # # #                 count[n2] -= 1

# # # # # # # # # # # # # # # # # # # # # # # #                 n3 = -1 * (n1 + n2)
                
# # # # # # # # # # # # # # # # # # # # # # # #                 if n3 in count and count[n3] > 0:
# # # # # # # # # # # # # # # # # # # # # # # #                     lst = list([n1, n2, n3])
# # # # # # # # # # # # # # # # # # # # # # # #                     lst.sort()
# # # # # # # # # # # # # # # # # # # # # # # #                     ans.add(lst)
                
# # # # # # # # # # # # # # # # # # # # # # # #                 count[n2] += 1
# # # # # # # # # # # # # # # # # # # # # # # #             count[n1] += 1
        
# # # # # # # # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # # print(solution.threeSum([-1,0,1,2,-1,-4]))         

# # # # # # # # # # # # # # # # # # # # # # # from typing import List


# # # # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # # # #     def trap(self, arr: List[int]) -> int:
# # # # # # # # # # # # # # # # # # # # # # #         n = len(arr)
# # # # # # # # # # # # # # # # # # # # # # #         lMax = [0] * n
# # # # # # # # # # # # # # # # # # # # # # #         rMax = [0] * n

# # # # # # # # # # # # # # # # # # # # # # #         tMax = 0

# # # # # # # # # # # # # # # # # # # # # # #         for i in range(n):
# # # # # # # # # # # # # # # # # # # # # # #             if arr[i] > tMax:
# # # # # # # # # # # # # # # # # # # # # # #                 tMax = arr[i]
# # # # # # # # # # # # # # # # # # # # # # #             lMax[i] = tMax
        
# # # # # # # # # # # # # # # # # # # # # # #         tMax = 0

# # # # # # # # # # # # # # # # # # # # # # #         for i in range(n - 1, -1, -1):
# # # # # # # # # # # # # # # # # # # # # # #             if arr[i] > tMax:
# # # # # # # # # # # # # # # # # # # # # # #                 tMax = arr[i]
# # # # # # # # # # # # # # # # # # # # # # #             rMax[n - 1 - i] = tMax
        
# # # # # # # # # # # # # # # # # # # # # # #         print(lMax)
# # # # # # # # # # # # # # # # # # # # # # #         print(rMax)
        
# # # # # # # # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # # # # # # # #         for i in range(n):
# # # # # # # # # # # # # # # # # # # # # # #             ans += (min(lMax[i], rMax[i]) - arr[i])
        
# # # # # # # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # # # print(solution.trap([0,1,0,2,1,0,1,3,2,1,2,1]))

# # # # # # # # # # # # # # # # # # # # # # arr = [5, 3, 6, 8, 1, 4]
# # # # # # # # # # # # # # # # # # # # # # arr.sort()
# # # # # # # # # # # # # # # # # # # # # # arr.reverse()

# # # # # # # # # # # # # # # # # # # # # # print(arr)


# # # # # # # # # # # # # # # # # # # # # from typing import List

# # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # #     def isPossible(self, arr, k, mid):
# # # # # # # # # # # # # # # # # # # # #         count = 0
# # # # # # # # # # # # # # # # # # # # #         n = -1  
# # # # # # # # # # # # # # # # # # # # #         for i in range(len(arr)):
# # # # # # # # # # # # # # # # # # # # #             if arr[i] > mid:
# # # # # # # # # # # # # # # # # # # # #                 break
# # # # # # # # # # # # # # # # # # # # #             n = i

# # # # # # # # # # # # # # # # # # # # #         for i in range(n + 1):  
# # # # # # # # # # # # # # # # # # # # #             count += 1
# # # # # # # # # # # # # # # # # # # # #             k -= (mid - arr[i])
# # # # # # # # # # # # # # # # # # # # #             if k <= 0:
# # # # # # # # # # # # # # # # # # # # #                 break

# # # # # # # # # # # # # # # # # # # # #         return count >= n + 1  

# # # # # # # # # # # # # # # # # # # # #     def maxFrequency(self, arr: List[int], k: int) -> int:
# # # # # # # # # # # # # # # # # # # # #         arr.sort()
# # # # # # # # # # # # # # # # # # # # #         ans = 0
# # # # # # # # # # # # # # # # # # # # #         s = min(arr)
# # # # # # # # # # # # # # # # # # # # #         e = max(arr)

# # # # # # # # # # # # # # # # # # # # #         while s <= e:
# # # # # # # # # # # # # # # # # # # # #             mid =  (s + e) // 2

# # # # # # # # # # # # # # # # # # # # #             if self.isPossible(arr, k, mid):  
# # # # # # # # # # # # # # # # # # # # #                 s = mid + 1
# # # # # # # # # # # # # # # # # # # # #                 ans = mid
# # # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # # #                 e = mid - 1
        
# # # # # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # result = solution.maxFrequency([3,9,6], 2)
# # # # # # # # # # # # # # # # # # # # # print(result)


# # # # # # # # # # # # # # # # # # # # # arr = [1, 3, 5]

# # # # # # # # # # # # # # # # # # # # # position = [0] * (len(arr) - 1)

# # # # # # # # # # # # # # # # # # # # # for i in range(1, len(arr)):
# # # # # # # # # # # # # # # # # # # # #     position[i - 1] = arr.index(arr[i])

# # # # # # # # # # # # # # # # # # # # # print(position)

# # # # # # # # # # # # # # # # # # # # from typing import List

# # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # #     def reductionOperations(self, arr: List[int]) -> int:
# # # # # # # # # # # # # # # # # # # # #         arr.sort()
# # # # # # # # # # # # # # # # # # # # #         n = len(arr)
# # # # # # # # # # # # # # # # # # # # #         arr = list(set(arr))
# # # # # # # # # # # # # # # # # # # # #         position = [0] * (len(arr) - 1)

# # # # # # # # # # # # # # # # # # # # #         for i in range(1, len(arr)):
# # # # # # # # # # # # # # # # # # # # #             position[i - 1] = arr.index(arr[i])

# # # # # # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # # # # # #         for i in position:
# # # # # # # # # # # # # # # # # # # # #             ans += n - i

# # # # # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # print(solution.reductionOperations([5,1,3]))

# # # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # # #     def helper(self, a, n):
# # # # # # # # # # # # # # # # # # # # #         # BASE CASE:
# # # # # # # # # # # # # # # # # # # # #         if n == 1:
# # # # # # # # # # # # # # # # # # # # #             return a
        
# # # # # # # # # # # # # # # # # # # # #         if (n & 1) == 1:
# # # # # # # # # # # # # # # # # # # # #             return a * self.helper(a * a, (n - 1) // 2)
# # # # # # # # # # # # # # # # # # # # #         else:
# # # # # # # # # # # # # # # # # # # # #             return self.helper(a * a, n // 2)


# # # # # # # # # # # # # # # # # # # # #     def superPow(self, a: int, b: List[int]) -> int:
# # # # # # # # # # # # # # # # # # # # #         n = ""
# # # # # # # # # # # # # # # # # # # # #         for i in b:
# # # # # # # # # # # # # # # # # # # # #             n += str(i)
# # # # # # # # # # # # # # # # # # # # #         n = int(n)
# # # # # # # # # # # # # # # # # # # # #         print(n&1)

# # # # # # # # # # # # # # # # # # # # #         if a == 1 or n == 0:
# # # # # # # # # # # # # # # # # # # # #             return 1
# # # # # # # # # # # # # # # # # # # # #         base = a
# # # # # # # # # # # # # # # # # # # # #         return self.helper(a, n)

# # # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # # print(solution.helper(2, 10))

# # # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # # #     def rev(self, num):
# # # # # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # # # # #         while(num > 0):
# # # # # # # # # # # # # # # # # # # #             ans *= 10
# # # # # # # # # # # # # # # # # # # #             l = num % 10
# # # # # # # # # # # # # # # # # # # #             ans += l
# # # # # # # # # # # # # # # # # # # #             num = num // 10

# # # # # # # # # # # # # # # # # # # #         return ans 

# # # # # # # # # # # # # # # # # # # #     def countNicePairs(self, arr: List[int]) -> int:
# # # # # # # # # # # # # # # # # # # #         m = (10 ** 9) + 7
# # # # # # # # # # # # # # # # # # # #         ans = 0
# # # # # # # # # # # # # # # # # # # #         n = len(arr)
# # # # # # # # # # # # # # # # # # # #         count = {}

# # # # # # # # # # # # # # # # # # # #         for i in range(n):
# # # # # # # # # # # # # # # # # # # #             arr[i] = arr[i] - self.rev(arr[i])
# # # # # # # # # # # # # # # # # # # #             if arr[i] in count:
# # # # # # # # # # # # # # # # # # # #                 count[arr[i]] += 1
# # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # #                 count[arr[i]] = 1
# # # # # # # # # # # # # # # # # # # #         print(arr)
# # # # # # # # # # # # # # # # # # # #         print(count)
        
# # # # # # # # # # # # # # # # # # # #         for i in count.values():
# # # # # # # # # # # # # # # # # # # #             if i == 1:
# # # # # # # # # # # # # # # # # # # #                 continue
# # # # # # # # # # # # # # # # # # # #             elif i == 2:
# # # # # # # # # # # # # # # # # # # #                 ans += 1
# # # # # # # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # # # # # # #                 ans += ((i - 1) * (i)) >> 1
        
# # # # # # # # # # # # # # # # # # # #         return ans % m

    

    
# # # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # # print(solution.countNicePairs([13,10,35,24,76]))

# # # # # # # # # # # # # # # # # # # from typing import List

# # # # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # # # #     def findDiagonalOrder(self, arr: List[List[int]]) -> List[int]:
# # # # # # # # # # # # # # # # # # #         lst = []
# # # # # # # # # # # # # # # # # # #         if not arr:
# # # # # # # # # # # # # # # # # # #             return []

# # # # # # # # # # # # # # # # # # #         for r in range(len(arr)):
# # # # # # # # # # # # # # # # # # #             for c in range(len(arr[r])):
# # # # # # # # # # # # # # # # # # #                 s = (r + c)
# # # # # # # # # # # # # # # # # # #                 lst.append([s, r, arr[r][c]])
        
# # # # # # # # # # # # # # # # # # #         lst.sort(key=lambda x: (x[0], -x[1]))
# # # # # # # # # # # # # # # # # # #         ans = [0] *  len(lst)

# # # # # # # # # # # # # # # # # # #         for i in range(len(lst)):
# # # # # # # # # # # # # # # # # # #             ans[i] = lst[i][2]
        
# # # # # # # # # # # # # # # # # # #         return ans


# # # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # # print(solution.findDiagonalOrder([[1,2,3],[4,5,6],[7,8,9]]))
# # # # # # # # # # # # # # # # # # from typing import List

# # # # # # # # # # # # # # # # # # class Solution:

# # # # # # # # # # # # # # # # # #     def findDiagonalOrder(self, arr: List[List[int]]) -> List[int]:
# # # # # # # # # # # # # # # # # #         lst = []
# # # # # # # # # # # # # # # # # #         if not arr:
# # # # # # # # # # # # # # # # # #             return []

# # # # # # # # # # # # # # # # # #         for r in range(len(arr)):
# # # # # # # # # # # # # # # # # #             for c in range(len(arr[r])):
# # # # # # # # # # # # # # # # # #                 s = (r + c)
# # # # # # # # # # # # # # # # # #                 lst.append([s, r, c, arr[r][c]])
        
# # # # # # # # # # # # # # # # # #         lst.sort(key=lambda x: (x[0], x[1]) if s % 2 == 1 else (x[0], -x[1]))
# # # # # # # # # # # # # # # # # #         ans = [0] *  len(lst)

# # # # # # # # # # # # # # # # # #         for i in range(len(lst)):
# # # # # # # # # # # # # # # # # #             ans[i] = lst[i][3]
        
# # # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # # # print(solution.findDiagonalOrder([[1,2,3],[4,5,6],[7,8,9]]))

# # # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # # #     def helper(self, possibility, n, dp, cell):
# # # # # # # # # # # # # # # # #         if n == 0:
# # # # # # # # # # # # # # # # #             return 1
        
# # # # # # # # # # # # # # # # #         if dp[n, cell] != -1:
# # # # # # # # # # # # # # # # #             return dp[n, cell]
        
# # # # # # # # # # # # # # # # #         ans = 0

# # # # # # # # # # # # # # # # #         for i in possibility[cell]:
# # # # # # # # # # # # # # # # #             ans += self.helper(possibility, n - 1, dp, i)

# # # # # # # # # # # # # # # # #         dp[n][cell] = ans
# # # # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # # #     def knightDialer(self, n: int) -> int:
# # # # # # # # # # # # # # # # #         possibility = [
# # # # # # # # # # # # # # # # #             [4, 6],
# # # # # # # # # # # # # # # # #             [6, 8],
# # # # # # # # # # # # # # # # #             [7, 9],
# # # # # # # # # # # # # # # # #             [4, 8],
# # # # # # # # # # # # # # # # #             [3, 9, 0],
# # # # # # # # # # # # # # # # #             [],
# # # # # # # # # # # # # # # # #             [1, 7, 0],
# # # # # # # # # # # # # # # # #             [2, 6],
# # # # # # # # # # # # # # # # #             [1, 3],
# # # # # # # # # # # # # # # # #             [2, 4]
# # # # # # # # # # # # # # # # #         ]

# # # # # # # # # # # # # # # # #         dp = [[-1] * 5001] * 10

# # # # # # # # # # # # # # # # from typing import List

# # # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # # #     def maxProduct(self, words: List[str]) -> int:
# # # # # # # # # # # # # # # #         ans = 0
# # # # # # # # # # # # # # # #         for i in range(len(words)):
# # # # # # # # # # # # # # # #             for j in range(i + 1, len(words)):
# # # # # # # # # # # # # # # #                 w1 = set(words[i])
# # # # # # # # # # # # # # # #                 w2 = set(words[j])

# # # # # # # # # # # # # # # #                 if w1&w2 == set() and len(w1) * len(w2) > ans:
# # # # # # # # # # # # # # # #                     ans = len(w1) * len(w2)
        
# # # # # # # # # # # # # # # #         return ans
# # # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # # print(solution.maxProduct(["abcw","baz","foo","bar","xtfn","abcdef"]))

# # # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # # #     def longestContinuousSubstring(self, string: str) -> int:
# # # # # # # # # # # # # # #         n = len(string)
# # # # # # # # # # # # # # #         ans = 0
# # # # # # # # # # # # # # #         s = 0
# # # # # # # # # # # # # # #         e = 0

# # # # # # # # # # # # # # #         while s < n and e < n:
# # # # # # # # # # # # # # #             if e + 1 < n and ord(string[e + 1]) - ord(string[e]) == 1:
# # # # # # # # # # # # # # #                 e += 1
# # # # # # # # # # # # # # #                 if (e - s) + 1 > ans:
# # # # # # # # # # # # # # #                     ans = e - s + 1
# # # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # # #                 s = e + 1  
# # # # # # # # # # # # # # #                 e = s

# # # # # # # # # # # # # # #         return ans

# # # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # # print(solution.longestContinuousSubstring("abadeabc"))



# # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # #     def numberOfWays(self, corridor: str) -> int:
# # # # # # # # # # # # # #         ans = 0
# # # # # # # # # # # # # #         n = len(corridor)
# # # # # # # # # # # # # #         segments = []
# # # # # # # # # # # # # #         c = 0
# # # # # # # # # # # # # #         cSeat = 0
# # # # # # # # # # # # # #         temp = [0, 0]

# # # # # # # # # # # # # #         for i in range(n):
# # # # # # # # # # # # # #             if corridor[i] == 'S':
# # # # # # # # # # # # # #                 c += 1
# # # # # # # # # # # # # #                 cSeat += 1
# # # # # # # # # # # # # #                 if cSeat == 1:
# # # # # # # # # # # # # #                     temp[0] = i
# # # # # # # # # # # # # #                 elif cSeat == 2:
# # # # # # # # # # # # # #                     temp[1] = i
# # # # # # # # # # # # # #                     cSeat = 0
# # # # # # # # # # # # # #                     segments.append(temp)
# # # # # # # # # # # # # #                     temp = [0, 0]
# # # # # # # # # # # # # #         if c&1 == 1:
# # # # # # # # # # # # # #             return ans
# # # # # # # # # # # # # #         elif(len(segments) >= 1):
# # # # # # # # # # # # # #             ans = 1
        
# # # # # # # # # # # # # #         for i in range(1, len(segments)):
# # # # # # # # # # # # # #             if segments[i][0] - segments[i - 1][1] > 1:
# # # # # # # # # # # # # #                 ans += segments[i][0] - segments[i - 1][1]
        
# # # # # # # # # # # # # #         return ans
# # # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # # print(solution.numberOfWays("SPPSSSSPPS"))

# # # # # # # # # # # # # # """
# # # # # # # # # # # # # # TRY - 1

# # # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # # #     def numberOfWays(self, corridor: str) -> int:
# # # # # # # # # # # # # #         if len(corridor) <= 1:
# # # # # # # # # # # # # #             return 0
# # # # # # # # # # # # # #         ans = 1
# # # # # # # # # # # # # #         cSeat = 0
# # # # # # # # # # # # # #         cPlant = 0
# # # # # # # # # # # # # #         string = ""

# # # # # # # # # # # # # #         i = corridor.index('P')

# # # # # # # # # # # # # #         for i in range(i, len(corridor)):
# # # # # # # # # # # # # #             if corridor[i] == 'P':
# # # # # # # # # # # # # #                 cPlant += 1
# # # # # # # # # # # # # #             elif corridor[i] == 'S':
# # # # # # # # # # # # # #                 cSeat += 1
            
# # # # # # # # # # # # # #             if cSeat == 2:
# # # # # # # # # # # # # #                 ans *= (cPlant + 1)
# # # # # # # # # # # # # #                 cSeat = 0
# # # # # # # # # # # # # #                 cPlant = 0
            
# # # # # # # # # # # # # #         return ans
# # # # # # # # # # # # # # """
# # # # # # # # # # # # # import sys

# # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # #     def bestClosingTime(self, s: str) -> int:
# # # # # # # # # # # # #         n = len(s)
# # # # # # # # # # # # #         if s.count('N') == 0:
# # # # # # # # # # # # #             return n
# # # # # # # # # # # # #         elif s.count('Y') == 0:
# # # # # # # # # # # # #             return 0
# # # # # # # # # # # # #         ans = sys.maxsize
# # # # # # # # # # # # #         hour = 0

# # # # # # # # # # # # #         j = 0

# # # # # # # # # # # # #         while j <= n:
# # # # # # # # # # # # #             if j == 0:
# # # # # # # # # # # # #                 temp = s.count('Y')
# # # # # # # # # # # # #             elif j < n:
# # # # # # # # # # # # #                 temp = s[:j].count('N') + s[j:].count('Y')
# # # # # # # # # # # # #             else:
# # # # # # # # # # # # #                 temp = s.count('N')
            
# # # # # # # # # # # # #             if temp < ans:
# # # # # # # # # # # # #                 ans = temp
# # # # # # # # # # # # #                 hour = j

# # # # # # # # # # # # #             j += 1
        
# # # # # # # # # # # # #         return hour
            

# # # # # # # # # # # # #         # for i in range(n):
# # # # # # # # # # # # #         #     open = s[:i]
# # # # # # # # # # # # #         #     closed = s[i:]

# # # # # # # # # # # # #         #     if (open.count('N') + closed.count('Y')) < ans:
# # # # # # # # # # # # #         #         ans = (open.count('N') + closed.count('Y'))
# # # # # # # # # # # # #         #         print(ans)
# # # # # # # # # # # # #         #         hour = i
        
# # # # # # # # # # # # #         # return hour

# # # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # # print(solution.bestClosingTime("YNYY"))   

# # # # # # # # # # # # # class Solution:
# # # # # # # # # # # # #     def bestClosingTime(self, s: str) -> int:
# # # # # # # # # # # # #         n = len(s)
# # # # # # # # # # # # #         open_count = s.count('Y')
# # # # # # # # # # # # #         close_count = s.count('N')
# # # # # # # # # # # # #         current_close = s[:n - 1].count('Y') if s else 0
# # # # # # # # # # # # #         ans = close_count  
# # # # # # # # # # # # #         hour = n - 1

# # # # # # # # # # # # #         for i, char in enumerate(s):
# # # # # # # # # # # # #             if char == 'Y':
# # # # # # # # # # # # #                 open_count -= 1
# # # # # # # # # # # # #             else:
# # # # # # # # # # # # #                 current_close += 1

# # # # # # # # # # # # #             if i < n - 1 and open_count + current_close < ans:
# # # # # # # # # # # # #                 ans = open_count + current_close
# # # # # # # # # # # # #                 hour = i

# # # # # # # # # # # # #         return hour


# # # # # # # # # # # # class Solution:
# # # # # # # # # # # #     def bestClosingTime(self, s: str) -> int:
# # # # # # # # # # # #         n = len(s)
        
# # # # # # # # # # # #         cY = s.count('Y') if s else 0
# # # # # # # # # # # #         m = cY
# # # # # # # # # # # #         ans = 0

# # # # # # # # # # # #         for i in range(1, n):
# # # # # # # # # # # #             if s[i - 1] == 'Y':
# # # # # # # # # # # #                 temp = m - 1
# # # # # # # # # # # #             else:
# # # # # # # # # # # #                 temp = m + 1
            
# # # # # # # # # # # #             if temp < m:
# # # # # # # # # # # #                 m = temp
# # # # # # # # # # # #                 ans = i
        
# # # # # # # # # # # #         if s.count('N') < m:
# # # # # # # # # # # #             ans = n
        
# # # # # # # # # # # #         return ans

# # # # # # # # # # # # solution = Solution()
# # # # # # # # # # # # print(solution.bestClosingTime("YYYY")) 

# # # # # # # # # # # # class Solution:
# # # # # # # # # # # #     def bestClosingTime(self, customers: str) -> int:
# # # # # # # # # # # #         bestTime, penaltyDiff = 0, 0
            
# # # # # # # # # # # #         for i in range(0, len(customers)):
# # # # # # # # # # # #             if customers[i] == 'Y':
# # # # # # # # # # # #                 penaltyDiff -= 1
# # # # # # # # # # # #             else:
# # # # # # # # # # # #                 penaltyDiff += 1
            
# # # # # # # # # # # #             if penaltyDiff < 0:
# # # # # # # # # # # #                 penaltyDiff = 0;
# # # # # # # # # # # #                 bestTime = i + 1;
# # # # # # # # # # # #         return bestTime;



# # # # # # # # # # # for 

# # # # # # # # # # # for 

# # # # # # # # # # # for 

# # # # # # # # # # # for 

# # # # # # # # # # # for 


# # # # # # # # # # # END.

# # # # # # # # # # s


# # # # # # # # # class Solution:
# # # # # # # # #     def minimumOneBitOperations(self, n: int) -> int:
# # # # # # # # #         data = {i: 0 for i in range(0, 32)}
# # # # # # # # #         x = 1
# # # # # # # # #         for i in range(0, 32):
# # # # # # # # #             data[i] = 2 * i + x
# # # # # # # # #             x = data[i]
# # # # # # # # #         print(data)

# # # # # # # # #         num = bin(n)
# # # # # # # # #         num = num[2:]
# # # # # # # # #         print(num)
# # # # # # # # #         ans = data[len(num) - 1]
# # # # # # # # #         print(ans)

# # # # # # # # #         temp = -1
# # # # # # # # #         for i in range(1, len(num)):
# # # # # # # # #             if num[i] == '1':
# # # # # # # # #                 ans += temp * data[len(num) - i - 1]
# # # # # # # # #                 temp *= -1
        
# # # # # # # # #         return ans

# # # # # # # # # s = Solution()

# # # # # # # # # print(s.minimumOneBitOperations(9))

# # # # # # # # from typing import List


# # # # # # # # class Solution:
# # # # # # # #     def threeSum(self, arr: List[int]) -> List[List[int]]:
# # # # # # # #         n = len(arr)
# # # # # # # #         arr.sort()
# # # # # # # #         ans = []

# # # # # # # #         for i in range(n):
# # # # # # # #             if arr[i] > 0:
# # # # # # # #                 break
# # # # # # # #             if i > 0 and arr[i] == arr[i - 1]:
# # # # # # # #                 continue
# # # # # # # #             s = i + 1
# # # # # # # #             e = n - 1
# # # # # # # #             target = -arr[i]

# # # # # # # #             while(s < e):
# # # # # # # #                 temp = arr[s] + arr[e]
# # # # # # # #                 if temp == target:
# # # # # # # #                     ans.append([arr[i], arr[s], arr[e]])
# # # # # # # #                     s += 1
# # # # # # # #                     e -= 1
# # # # # # # #                     while (s < e and arr[s] == arr[s - 1]):
# # # # # # # #                         s += 1
# # # # # # # #                 elif temp < target:
# # # # # # # #                     s += 1
# # # # # # # #                 else:
# # # # # # # #                     e -= 1

# # # # # # # #         return ans

# # # # # # # # s = Solution()
# # # # # # # # print(s.threeSum([-1,0,1,2,-1,-4]))


# # # # # # # # class Solution:
# # # # # # # #     def threeSum(self, arr: List[int]) -> List[List[int]]:
# # # # # # # #         arr.sort()
# # # # # # # #         n = len(arr)
# # # # # # # #         res = []
        
# # # # # # # #         for i in range(n):
# # # # # # # #             if arr[i] > 0:
# # # # # # # #                 break
# # # # # # # #             if i > 0 and arr[i] == arr[i - 1]:
# # # # # # # #                 continue
# # # # # # # #             target = -arr[i]
# # # # # # # #             left, right = i + 1, n - 1
# # # # # # # #             while left < right:
# # # # # # # #                 two_sum = arr[left] + arr[right]
# # # # # # # #                 if two_sum == target:
# # # # # # # #                     res.append([arr[i], arr[left], arr[right]])
# # # # # # # #                     left += 1
# # # # # # # #                     right -= 1
# # # # # # # #                     while left < right and arr[left] == arr[left - 1]:
# # # # # # # #                         left += 1
# # # # # # # #                 elif two_sum < target:
# # # # # # # #                     left += 1
# # # # # # # #                 else:
# # # # # # # #                     right -= 1
        
# # # # # # # #         return res
                

# # # # # # # from typing import List


# # # # # # # class Solution:
# # # # # # #     def threeSum(self, arr: List[int]) -> List[List[int]]:
# # # # # # #         n = len(arr)
# # # # # # #         arr.sort()
# # # # # # #         ans = []

# # # # # # #         for i in range(n):
# # # # # # #             if arr[i] > 0:
# # # # # # #                 break
# # # # # # #             if i > 0 and arr[i] == arr[i - 1]:
# # # # # # #                 continue
# # # # # # #             s = i + 1
# # # # # # #             e = n - 1
# # # # # # #             target = -arr[i]

# # # # # # #             while(s < e):
# # # # # # #                 temp = arr[s] + arr[e]
# # # # # # #                 if temp == target:
# # # # # # #                     ans.append([arr[i], arr[s], arr[e]])
# # # # # # #                     s += 1
# # # # # # #                     e -= 1
# # # # # # #                     while (s < e and arr[s] == arr[s - 1]):
# # # # # # #                         s += 1
# # # # # # #                 elif temp < target:
# # # # # # #                     s += 1
# # # # # # #                 else:
# # # # # # #                     e -= 1

# # # # # # #         return ans

# # # # # # class Solution:
# # # # # #     def threeSumClosest(self, arr: List[int], target: int) -> int:
# # # # # #         n = len(arr)
# # # # # #         arr.sort()
# # # # # #         ans = 0
# # # # # #         diff = float('inf') 

# # # # # #         for i in range(n - 2):
# # # # # #             s = i + 1
# # # # # #             e = n - 1

# # # # # #             while s < e:
# # # # # #                 sum = arr[i] + arr[s] + arr[e]
# # # # # #                 temp = abs(sum - target)

# # # # # #                 if temp < diff:
# # # # # #                     diff = temp
# # # # # #                     ans = sum

# # # # # #                 if sum < target:
# # # # # #                     s += 1
# # # # # #                 else:
# # # # # #                     e -= 1

# # # # # #         return ans

# # # # # from typing import List


# # # # # # class Solution:
# # # # # #     def isValid(self, word, data):
# # # # # #         temp = data

# # # # # #         for ch in word:
# # # # # #             if ch not in temp:
# # # # # #                 return False
# # # # # #             temp[ch] -= 1
# # # # # #             if temp[ch] < 0:
# # # # # #                 return False
        
# # # # # #         return True

# # # # # #     def countCharacters(self, words: List[str], chars: str) -> int:
# # # # # #         data = {}
# # # # # #         ans = 0

# # # # # #         for ch in words:
# # # # # #             if ch not in data:
# # # # # #                 data[ch] = 1
# # # # # #             else:
# # # # # #                 data[ch] += 1
        
# # # # # #         for word in words:
# # # # # #             if self.isValid(word, data):
# # # # # #                 ans += len(word)
        
# # # # # #         return ans

# # # # # # s = Solution()
# # # # # # data = {'a': 2, 't': 1, 'c': 1, 'h': 1}

# # # # # # print(s.countCharacters(["cat","bt","hat","tree"], "atach"))
# # # # # # print(s.isValid("hat", data))

# # # # # from typing import List

# # # # # class Solution:
# # # # #     def isValid(self, word, data):
# # # # #         for ch in word:
# # # # #             if ch not in data or data[ch] == 0:
# # # # #                 return False
# # # # #             data[ch] -= 1
        
# # # # #         return True

# # # # #     def countCharacters(self, words: List[str], chars: str) -> int:
# # # # #         data = {}

# # # # #         for ch in chars:
# # # # #             if ch not in data:
# # # # #                 data[ch] = 1
# # # # #             else:
# # # # #                 data[ch] += 1

# # # # #         ans = 0
# # # # #         for word in words:
# # # # #             if self.isValid(word, data.copy()):
# # # # #                 ans += len(word)
        
# # # # #         return ans
    
# # # # # s = Solution()
# # # # # print(s.countCharacters(["cat","bt","hat","tree"], "atach"))




# # # # #     # def countCharacters(self, words: List[str], chars: str) -> int:
# # # # #     #     data = {}
# # # # #     #     ans = 0

# # # # #     #     for ch in words:
# # # # #     #         if ch not in data:
# # # # #     #             data[ch] = 1
# # # # #     #         else:
# # # # #     #             data[ch] += 1
        
# # # # #     #     for word in words:
# # # # #     #         for ch in word:
# # # # #     #             if ch not in data or :
# # # # #     #                 continue
# # # # #     #             elif


# # # # from typing import List

# # # # class Solution:
# # # #     def isValid(self, word, data):
# # # #         for ch in word:
# # # #             if ch not in data or data[ch] == 0:
# # # #                 return False
# # # #             data[ch] -= 1
        
# # # #         return True

# # # #     def countCharacters(self, words: List[str], chars: str) -> int:
# # # #         data = {}

# # # #         for ch in chars:
# # # #             if ch not in data:
# # # #                 data[ch] = 1
# # # #             else:
# # # #                 data[ch] += 1

# # # #         ans = 0
# # # #         for word in words:
# # # #             if self.isValid(word, data.copy()):
# # # #                 ans += len(word)
        
# # # #         return ans
    
# # # # s = Solution()
# # # # print(s.countCharacters(["cat","bt","hat","tree"], "atach"))

# # # class Solution:
# # #     def largestGoodInteger(self, num: str) -> str:
# # #         res = ""
# # #         n = len(num)
# # #         ans = -1
# # #         s = e = 0
# # #         l = 0

# # #         while (s < n and e < n - 1):
# # #             if e + 1 < n and num[e + 1] == num[s]:
# # #                 l += 1
# # #                 e += 1
            
# # #             if l >= 2 and int(num[s]) > int(ans):
# # #                 res = num[s:e + 1]
# # #                 ans = num[s]

# # #             if (e + 1 < n and num[e + 1] != num[s]):
# # #                 l = 0
# # #                 s = e + 1
# # #                 e = s
            
# # #         # return "" if ans == -1 else ans
# # #         return res

# # # s = Solution()
# # # print(s.largestGoodInteger("222"))

# # from typing import List


# # class Solution:
# #     def BS (self, arr, s, e, target):
# #         while (s <= e):
# #             mid = s + (e - s) // 2

# #             if arr[mid] == target:
# #                 return mid
# #             elif arr[mid] > target:
# #                 e = mid - 1
# #             else:
# #                 s = mid + 1
        
# #         return -1

# #     def twoSum(self, arr: List[int], target: int) -> List[int]:
# #         n = len(arr)

# #         for i in range(n - 1):
# #             s = i + 1
# #             e = n - 1
# #             t = target - arr[i]

# #             sRes = self.BS(arr, s, e, t)

# #             if sRes != -1:
# #                 return [s, sRes + 1]
# #         return [-1, -1]
# # print(s.BS([2,7,11,15], 1, 3, 7))

# arr1 = ["word","note","ants","wood"]
# arr2 = ["wood","joke","moat"]

# for word in arr1:
  

# arr1.sort()
# arr2.sort()

# print(arr1)
# print(arr2)

# n = "1234521"
# for i in n:
#     print(i)

class Solution:
    def largestOddNumber(self, num: str) -> str:
        ans = -100

        for ch in num:
            n = int(ch)
            if n%2 == 1 and n > ans:
                ans = n
        
        return str(ans)

s = Solution()
print(s.largestOddNumber("1213"))